# 3D Model Animation Guide: Blender to GSAP

This guide walks you through the process of preparing a 3D model in Blender, exporting it, and animating it in a React Three Fiber project using GSAP.

## Part 1: Blender Preparation

Proper preparation in Blender is critical for easy access to meshes in your code.

### 1. Naming Your Meshes
The most important step is giving your objects meaningful, unique names.
*   **Select an object** you want to animate (e.g., a door, a window, a car wheel).
*   Go to the **Object Properties** tab (orange square icon) in the right panel.
*   Rename the object in the top name field.
    *   *Bad:* `Cube.001`, `Cylinder`
    *   *Good:* `Penthouse_Door`, `Window_Frame_Left`, `Elevator_Car`
*   **Tip:** If you have a hierarchy (parent/child), name them clearly. When you import into React, flattened mesh names are easier to reference, but preserving hierarchy can be useful for grouped animations.

### 2. Apply Transforms
Before verifying, ensure your objects have their scale and rotation applied if you want "0,0,0" rotation to be the default state.
*   Select object -> `Ctrl + A` -> **Apply Scale** / **Apply Rotation**.
*   *Note:* Ensure the **Origin Point** of the object is where you want it to pivot (e.g., for a door, the origin should be at the hinge, not the center of the door).

### 3. Separation
If you want to animate a specific part (like a fan blade spinning), it **must be a separate object**, not just part of a larger mesh.
*   In Edit Mode, select the faces -> `P` -> **Separate Selection**.

## Part 2: Exporting to GLB

1.  Select the objects you want to export (or export everything).
2.  **File > Export > glTF 2.0 (.glb/.gltf)**.
3.  **Settings:**
    *   **Include:** Selected Objects (if you only want specific ones).
    *   **Transform:** +Y Up is standard for Three.js.
    *   **Mesh:** Apply Modifiers (usually checked).
4.  Save as `modelname.glb` in your project's `public/models/` folder.

## Part 3: Generating the React Component

We use `gltfjsx` to turn the GLB file into a declarative React component. This gives us direct access to the graph (nodes).

1.  Open your terminal in the project directory.
2.  Run the command:
    ```bash
    npx gltfjsx public/models/modelname.glb --transform --types
    ```
    *   `--types`: Generates TypeScript definitions.
    *   `--transform`: Optimizes the model (optional but recommended for web).
3.  This creates a file (e.g., `Modelname.tsx`) in your current directory. Move it to `src/components/`.

## Part 4: Animating with GSAP

Now that you have the component, you can animate specific nodes.

### 1. Identify the Node
Look at the generated TSX file. You will see something like:
```tsx
const { nodes, materials } = useGLTF('/models/penthouse.glb') as GLTFResult
```
And in the return statement:
```tsx
<mesh geometry={nodes.Penthouse_Door.geometry} ... />
```
Here, `nodes.Penthouse_Door` is the reference we want.

### 2. Setup the Animation
You need `useLayoutEffect` (or `useEffect`) and `useRef` (optional if animating the node directly, but recommended for clean logical grouping).

However, since `nodes.MeshName` is a Three.js object generic, strictly sticking to React refs is safest for hot-reloading, but referencing `nodes.MeshName` directly in GSAP works because the node object is stable after load.

**Preferred Approach: modifying the generated component**

```tsx
import React, { useLayoutEffect, useRef } from 'react'
import { useGLTF } from '@react-three/drei'
import gsap from 'gsap'

export function Penthouse(props) {
  const { nodes, materials } = useGLTF('/models/penthouse.glb')

  useLayoutEffect(() => {
    // 1. Target the specific mesh by its unique name from Blender
    const door = nodes.Penthouse_Door;
    
    if (door) {
      // Example: Open the door
      gsap.to(door.rotation, {
        y: Math.PI / 2, // Rotate 90 degrees
        duration: 2,
        ease: "power2.inOut",
        delay: 1
      });
    }

    // Example: Float an object
    const floatingSign = nodes.Sign_Post;
    if (floatingSign) {
       gsap.to(floatingSign.position, {
         y: "+=0.5", // Move up 0.5 units
         yoyo: true,
         repeat: -1,
         duration: 1.5,
         ease: "sine.inOut"
       });
    }

  }, [nodes]); // Run once when nodes are loaded

  return (
    <group {...props} dispose={null}>
      {/* The component code generated by gltfjsx... */}
      <mesh geometry={nodes.Penthouse_Door.geometry} material={materials.Wood} />
      {/* ... */}
    </group>
  )
}
```

### 3. External Control (Advanced)
If you want to control the animation from a parent component (like clicking a button to open the door), you can use `useImperativeHandle` or pass a prop.

**Example with Props:**
```tsx
export function Penthouse({ isOpen, ...props }) {
  const { nodes } = useGLTF(...)
  
  useEffect(() => {
    gsap.to(nodes.Door.rotation, {
      y: isOpen ? Math.PI / 2 : 0,
      duration: 1
    })
  }, [isOpen, nodes])
  
  return ...
}
```

## Checklist for Success
- [ ] **Blender:** Object origin is at rotation pivot.
- [ ] **Blender:** Object is uniquely named.
- [ ] **Code:** Component re-generated if names changed.
- [ ] **Code:** `useLayoutEffect` used for initial setup to prevent glitches.
